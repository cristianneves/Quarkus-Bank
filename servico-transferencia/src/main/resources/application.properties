# --- CONFIGURAÇÕES DE REDE ---
quarkus.http.port=8083
# Força o container de TESTE a subir na 8083
%test.quarkus.http.port=8083
quarkus.devservices.enabled=false

# --- BANCO DE DADOS (TRANSFERENCIA_DB - 5433) ---
quarkus.datasource.db-kind=postgresql
quarkus.datasource.jdbc.url=jdbc:postgresql://localhost:5433/transferencia_db
quarkus.datasource.username=admin
quarkus.datasource.password=admin

# Estratégia de geração do banco
quarkus.hibernate-orm.database.generation=update
%test.quarkus.hibernate-orm.database.generation=drop-and-create
%test.quarkus.datasource.jdbc.url=jdbc:postgresql://localhost:5433/transferencia_db

# Garante que o OIDC não trave a subida do teste se o Keycloak estiver offline
%test.quarkus.oidc.enabled=true

# ?? Faz o Quarkus imprimir no console EXATAMENTE por que recusou o token
quarkus.log.category."io.quarkus.oidc.runtime.OidcProvider".level=DEBUG
quarkus.log.category."io.quarkus.oidc.runtime.OidcAuthenticator".level=DEBUG

# --- SEGURANÇA (KEYCLOAK) ---
quarkus.oidc.auth-server-url=http://localhost:8180/realms/bank-realm
quarkus.oidc.client-id=quarkus-app
quarkus.oidc.application-type=service

# Diz ao Quarkus onde procurar as roles dentro do Token do Keycloak
quarkus.oidc.roles.role-claim-path=realm_access/roles

# --- MENSAGERIA (KAFKA CONSUMER & PRODUCER) ---
kafka.bootstrap.servers=localhost:9092
quarkus.kafka.snappy.enabled=false

# 1. CANAL: pessoa-registrada (Ouvindo o Cadastro)
# Produção: Escuta o Kafka real
mp.messaging.incoming.pessoa-registrada.connector=smallrye-kafka
mp.messaging.incoming.pessoa-registrada.topic=pessoas-registradas
mp.messaging.incoming.pessoa-registrada.value.deserializer=br.com.bb.transacoes.serialization.PessoaDeserializer

# Teste/Pipeline: Escuta a Memória (In-Memory)
# IMPORTANTE: NÃO CRIE UMA LINHA 'outgoing' PARA ESTE CANAL NO TESTE!
%test.mp.messaging.incoming.pessoa-registrada.connector=smallrye-in-memory

# 2. CANAL: transferencias-concluidas (Falando para o mundo)
# Produção: Envia para o Kafka real
mp.messaging.outgoing.transferencias-concluidas.connector=smallrye-kafka
mp.messaging.outgoing.transferencias-concluidas.topic=transacoes-bb
mp.messaging.outgoing.transferencias-concluidas.value.serializer=io.quarkus.kafka.client.serialization.ObjectMapperSerializer

# Teste/Pipeline: Envia para a Memória
%test.mp.messaging.outgoing.transferencias-concluidas.connector=smallrye-in-memory

# 3. CANAL: dead-letter-queue (Fila de Erros)
mp.messaging.incoming.pessoa-registrada.failure-strategy=dead-letter-queue
mp.messaging.incoming.pessoa-registrada.dead-letter-queue.topic=pessoa-registrada-dlq
mp.messaging.incoming.pessoa-registrada.dead-letter-queue.value.serializer=io.quarkus.kafka.client.serialization.ObjectMapperSerializer
%test.mp.messaging.outgoing.pessoa-registrada-dlq.connector=smallrye-in-memory

# --- QUALIDADE E FERRAMENTAS ---
quarkus.jackson.fail-on-empty-beans=false

# Configurações Sonar/Jacoco
quarkus.jacoco.report-location=jacoco-reports

sonar.java.binaries=target/classes
sonar.junit.reportPaths=target/surefire-reports
sonar.jacoco.reportPaths=target/jacoco-quarkus.exec
# O Sonar moderno exige o caminho do XML, não mais do .exec
sonar.coverage.jacoco.xmlReportPaths=target/jacoco-reports/jacoco.xml

# Limpeza de log: removendo a chave depreciada que causava WARN
%test.quarkus.hibernate-orm.generation=drop-and-create

