# Nome do canal no Java: transferencias-concluidas
# Conector: Kafka
# Tópico real no Kafka: transacoes-bb
mp.messaging.outgoing.transferencias-concluidas.connector=smallrye-kafka
mp.messaging.outgoing.transferencias-concluidas.topic=transacoes-bb
mp.messaging.outgoing.transferencias-concluidas.value.serializer=io.quarkus.kafka.client.serialization.ObjectMapperSerializer

quarkus.http.port=8080

# Configurações para o Sonar ler o Jacoco
sonar.java.binaries=target/classes
sonar.junit.reportPaths=target/surefire-reports
sonar.jacoco.reportPaths=target/jacoco-quarkus.exec

# Desliga a mágica
quarkus.devservices.enabled=false

# Força o Hibernate a apagar e criar as tabelas TODA VEZ que o teste rodar
# Isso garante que o import.sql seja executado sempre
%test.quarkus.hibernate-orm.database.generation=drop-and-create

# Garante que o banco de teste aponte para o nosso container fixo
%test.quarkus.datasource.jdbc.url=jdbc:postgresql://localhost:5435/bank_db
# Aponta para o Compose
quarkus.datasource.db-kind=postgresql
quarkus.datasource.jdbc.url=jdbc:postgresql://localhost:5435/bank_db
quarkus.datasource.username=quarkus
quarkus.datasource.password=quarkus

# Kafka
kafka.bootstrap.servers=localhost:9092
# Dá um fôlego para o Kafka responder durante os testes
quarkus.kafka.snappy.enabled=false

# Keycloak
quarkus.oidc.auth-server-url=http://localhost:8180/realms/bank-realm
quarkus.oidc.client-id=quarkus-app

# Como estamos usando um client público para testes
quarkus.oidc.application-type=service
